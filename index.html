<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Touchscreen Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #60a5fa;
        }
        
        .subtitle {
            text-align: center;
            color: #94a3b8;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .toggle-btn {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .conductor-mode {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
        }
        
        .insulator-mode {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }
        
        .mode-indicator {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
        }
        
        .canvas-container {
            background: #0f172a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }
        
        canvas {
            display: block;
            margin: 0 auto;
            border: 3px solid #475569;
            border-radius: 8px;
            cursor: crosshair;
            background: #1e293b;
        }
        
        .info-panel {
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid #475569;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
        }
        
        .info-panel h2 {
            color: #60a5fa;
            margin-top: 0;
            font-size: 1.8em;
            border-bottom: 2px solid #475569;
            padding-bottom: 10px;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            justify-content: center;
            margin-top: 0;
            padding: 0;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
        }
        
        .legend-color {
            width: 35px;
            height: 25px;
            border-radius: 4px;
            border: 2px solid white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Capacitive Touchscreen Simulation</h1>
        <p class="subtitle">Understanding How Your Device Detects Touch</p>
        
        <div class="controls">
            <button id="toggleMode" class="toggle-btn conductor-mode">Switch to Insulator Mode</button>
            <div id="modeIndicator" class="mode-indicator">Current Mode: <strong>Conductor</strong> (Finger)</div>
        </div>
        
        <div class="canvas-container">
            <canvas id="canvas" width="900" height="700"></canvas>
        </div>
        
        <div class="info-panel">
            <h2>Legend</h2>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ef4444;"></div>
                    <span>+ Horizontal Electrodes</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #3b82f6;"></div>
                    <span>− Vertical Electrodes</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #22d3ee;"></div>
                    <span>Electric Field</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #a855f7;"></div>
                    <span>Conductor Touch</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f59e0b;"></div>
                    <span>Insulator Touch</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #22c55e;"></div>
                    <span>Signal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #94a3b8;"></div>
                    <span>Wire Connection</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let isConductor = true;
        let touchPoints = [];
        let signals = [];
        
        const GRID = { rows: 3, cols: 3 };
        const MARGIN = 80;
        const gridWidth = canvas.width - 2 * MARGIN;
        const gridHeight = canvas.height - 2 * MARGIN;
        const cellWidth = gridWidth / GRID.cols;
        const cellHeight = gridHeight / GRID.rows;
        
        // Toggle mode
        document.getElementById('toggleMode').addEventListener('click', () => {
            isConductor = !isConductor;
            const btn = document.getElementById('toggleMode');
            const indicator = document.getElementById('modeIndicator');
            
            if (isConductor) {
                btn.textContent = 'Switch to Insulator Mode';
                btn.className = 'toggle-btn conductor-mode';
                indicator.innerHTML = 'Current Mode: <strong>Conductor</strong> (Finger)';
            } else {
                btn.textContent = 'Switch to Conductor Mode';
                btn.className = 'toggle-btn insulator-mode';
                indicator.innerHTML = 'Current Mode: <strong>Insulator</strong> (Glove)';
            }
        });
        
        // Handle clicks
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            // Check if click is in grid area
            if (x < MARGIN || x > canvas.width - MARGIN || y < MARGIN || y > canvas.height - MARGIN) {
                return;
            }
            
            const touchId = Date.now();
            touchPoints.push({
                x: x,
                y: y,
                id: touchId,
                alpha: 1.0
            });
            
            // Only generate signals if using a conductor (insulators don't trigger touchscreens!)
            if (isConductor) {
                // Find which electrodes
                const colIndex = Math.round((x - MARGIN) / cellWidth);
                const rowIndex = Math.round((y - MARGIN) / cellHeight);
                
                // Create signals
                signals.push({
                    id: `h-${touchId}`,
                    type: 'horizontal',
                    row: rowIndex,
                    startX: x,
                    startY: MARGIN + rowIndex * cellHeight,
                    endX: canvas.width - MARGIN + 20,
                    endY: canvas.height / 2 - 60 + (120 / (GRID.rows + 1)) * (rowIndex + 1),
                    progress: 0
                });
                
                signals.push({
                    id: `v-${touchId}`,
                    type: 'vertical',
                    col: colIndex,
                    startX: MARGIN + colIndex * cellWidth,
                    startY: y,
                    endX: canvas.width / 2 - 60 + (120 / (GRID.cols + 1)) * (colIndex + 1),
                    endY: canvas.height - MARGIN + 20,
                    progress: 0
                });
            }
            
            // Fade out touch after 2 seconds
            setTimeout(() => {
                const fadeInterval = setInterval(() => {
                    const touch = touchPoints.find(t => t.id === touchId);
                    if (touch) {
                        touch.alpha -= 0.05;
                        if (touch.alpha <= 0) {
                            touchPoints = touchPoints.filter(t => t.id !== touchId);
                            clearInterval(fadeInterval);
                        }
                    } else {
                        clearInterval(fadeInterval);
                    }
                }, 50);
            }, 2000);
        });
        
        function drawElectrodes() {
            // Draw horizontal positive electrodes (red)
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 4;
            
            for (let i = 0; i <= GRID.rows; i++) {
                const y = MARGIN + i * cellHeight;
                ctx.beginPath();
                ctx.moveTo(MARGIN, y);
                ctx.lineTo(canvas.width - MARGIN, y);
                ctx.stroke();
                
                // Draw + symbols
                ctx.fillStyle = '#ef4444';
                ctx.font = 'bold 20px Arial';
                for (let j = 0; j < GRID.cols; j++) {
                    const x = MARGIN + (j + 0.5) * cellWidth;
                    ctx.fillText('+', x - 6, y - 10);
                }
            }
            
            // Draw vertical negative electrodes (blue)
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 4;
            
            for (let i = 0; i <= GRID.cols; i++) {
                const x = MARGIN + i * cellWidth;
                ctx.beginPath();
                ctx.moveTo(x, MARGIN);
                ctx.lineTo(x, canvas.height - MARGIN);
                ctx.stroke();
                
                // Draw - symbols
                ctx.fillStyle = '#3b82f6';
                ctx.font = 'bold 20px Arial';
                for (let j = 0; j < GRID.rows; j++) {
                    const y = MARGIN + (j + 0.5) * cellHeight;
                    ctx.fillText('−', x + 10, y + 6);
                }
            }
            
            // Draw labels
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = '#ef4444';
            ctx.fillText('ROW +', 10, MARGIN + cellHeight / 2);
            ctx.fillStyle = '#3b82f6';
            ctx.fillText('COL −', MARGIN + cellWidth / 2 - 25, 20);
        }
        
        function drawControllers() {
            // Row controller (right side)
            ctx.fillStyle = 'rgba(239, 68, 68, 0.3)';
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 3;
            ctx.fillRect(canvas.width - MARGIN + 20, canvas.height / 2 - 60, 60, 120);
            ctx.strokeRect(canvas.width - MARGIN + 20, canvas.height / 2 - 60, 60, 120);
            
            ctx.fillStyle = '#ef4444';
            ctx.font = 'bold 12px Arial';
            ctx.save();
            ctx.translate(canvas.width - MARGIN + 50, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('ROW', -25, 5);
            ctx.fillText('CONTROLLER', -45, 20);
            ctx.restore();
            
            // Column controller (bottom)
            ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
            ctx.strokeStyle = '#3b82f6';
            ctx.fillRect(canvas.width / 2 - 60, canvas.height - MARGIN + 20, 120, 60);
            ctx.strokeRect(canvas.width / 2 - 60, canvas.height - MARGIN + 20, 120, 60);
            
            ctx.fillStyle = '#3b82f6';
            ctx.font = 'bold 12px Arial';
            ctx.fillText('COLUMN', canvas.width / 2 - 30, canvas.height - MARGIN + 45);
            ctx.fillText('CONTROLLER', canvas.width / 2 - 42, canvas.height - MARGIN + 60);
        }
        
        function drawWires() {
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            // Wires from horizontal electrodes to row controller
            for (let i = 0; i <= GRID.rows; i++) {
                const y = MARGIN + i * cellHeight;
                ctx.beginPath();
                ctx.moveTo(canvas.width - MARGIN, y);
                ctx.lineTo(canvas.width - MARGIN + 20, canvas.height / 2 - 60 + (120 / (GRID.rows + 1)) * (i + 1));
                ctx.stroke();
            }
            
            // Wires from vertical electrodes to column controller
            for (let i = 0; i <= GRID.cols; i++) {
                const x = MARGIN + i * cellWidth;
                ctx.beginPath();
                ctx.moveTo(x, canvas.height - MARGIN);
                ctx.lineTo(canvas.width / 2 - 60 + (120 / (GRID.cols + 1)) * (i + 1), canvas.height - MARGIN + 20);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
        }
        
        function drawFieldLines() {
            // Draw field lines for each cell
            for (let row = 0; row < GRID.rows; row++) {
                for (let col = 0; col < GRID.cols; col++) {
                    const cellX = MARGIN + col * cellWidth;
                    const cellY = MARGIN + row * cellHeight;
                    
                    // Draw 10 vertical field lines + 10 horizontal
                    for (let i = 0; i < 10; i++) {
                        // Vertical lines (from top edge to bottom edge of cell)
                        const x = cellX + (i + 1) * (cellWidth / 11);
                        drawFieldLine(x, cellY + 5, x, cellY + cellHeight - 5);
                        
                        // Horizontal lines
                        const y = cellY + (i + 1) * (cellHeight / 11);
                        drawFieldLine(cellX + 5, y, cellX + cellWidth - 5, y);
                    }
                }
            }
        }
        
        function drawFieldLine(x1, y1, x2, y2) {
            // Check if line is near any CONDUCTOR touch point
            let isDisrupted = false;
            let touchPoint = null;
            
            // Only disrupt field lines if it's a conductor
            if (isConductor) {
                for (const touch of touchPoints) {
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    const dx = midX - touch.x;
                    const dy = midY - touch.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 100) {
                        isDisrupted = true;
                        touchPoint = touch;
                        break;
                    }
                }
            }
            
            if (isDisrupted && touchPoint) {
                // Disrupted field line - only for conductors (orange)
                ctx.strokeStyle = `rgba(251, 191, 36, ${touchPoint.alpha * 0.5})`;
                ctx.lineWidth = 2;
                
                // Bend line toward touch (conductor attracts field lines)
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                
                const cp1x = (x1 + touchPoint.x) / 2;
                const cp1y = (y1 + touchPoint.y) / 2;
                const cp2x = (x2 + touchPoint.x) / 2;
                const cp2y = (y2 + touchPoint.y) / 2;
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
                
                ctx.stroke();
            } else {
                // Normal field line (cyan) - same for both modes when not disrupted
                ctx.strokeStyle = 'rgba(34, 211, 238, 0.4)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // Draw arrow
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const arrowSize = 6;
                
                ctx.beginPath();
                ctx.moveTo(midX, midY);
                ctx.lineTo(
                    midX - arrowSize * Math.cos(angle - Math.PI / 6),
                    midY - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                ctx.moveTo(midX, midY);
                ctx.lineTo(
                    midX - arrowSize * Math.cos(angle + Math.PI / 6),
                    midY - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                ctx.stroke();
            }
        }
        
        function drawTouchPoints() {
            for (const touch of touchPoints) {
                // Draw finger/insulator circle
                const color = isConductor ? '168, 85, 247' : '245, 158, 11';
                ctx.fillStyle = `rgba(${color}, ${touch.alpha * 0.4})`;
                ctx.strokeStyle = `rgba(${color}, ${touch.alpha * 0.8})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(touch.x, touch.y, 50, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Only draw rays for conductors (they actually disrupt the field)
                if (isConductor) {
                    // Conductor: rays pointing inward (field attracted to finger)
                    ctx.strokeStyle = `rgba(251, 191, 36, ${touch.alpha * 0.6})`;
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        const x1 = touch.x + Math.cos(angle) * 70;
                        const y1 = touch.y + Math.sin(angle) * 70;
                        const x2 = touch.x + Math.cos(angle) * 50;
                        const y2 = touch.y + Math.sin(angle) * 50;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                        
                        // Arrow pointing inward
                        ctx.beginPath();
                        ctx.moveTo(x2, y2);
                        ctx.lineTo(
                            x2 + 5 * Math.cos(angle + Math.PI * 2.5 / 3),
                            y2 + 5 * Math.sin(angle + Math.PI * 2.5 / 3)
                        );
                        ctx.moveTo(x2, y2);
                        ctx.lineTo(
                            x2 + 5 * Math.cos(angle - Math.PI * 2.5 / 3),
                            y2 + 5 * Math.sin(angle - Math.PI * 2.5 / 3)
                        );
                        ctx.stroke();
                    }
                }
                // Note: Insulators don't get rays because they don't disrupt the field
                
                // Label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                const label = isConductor ? 'FINGER' : 'INSULATOR';
                ctx.fillText(label, touch.x, touch.y - 65);
            }
        }
        
        function drawSignals() {
            for (let i = signals.length - 1; i >= 0; i--) {
                const signal = signals[i];
                signal.progress += 0.015;
                
                if (signal.progress >= 1) {
                    signals.splice(i, 1);
                    continue;
                }
                
                ctx.strokeStyle = '#22c55e';
                ctx.fillStyle = '#22c55e';
                ctx.lineWidth = 4;
                
                // Calculate current position along the path
                let currentX, currentY;
                
                if (signal.type === 'horizontal') {
                    // First part: travel along electrode to edge
                    if (signal.progress < 0.5) {
                        const localProgress = signal.progress / 0.5;
                        currentX = signal.startX + (canvas.width - MARGIN - signal.startX) * localProgress;
                        currentY = signal.startY;
                    } else {
                        // Second part: travel along wire to controller
                        const localProgress = (signal.progress - 0.5) / 0.5;
                        currentX = canvas.width - MARGIN + (signal.endX - (canvas.width - MARGIN)) * localProgress;
                        currentY = signal.startY + (signal.endY - signal.startY) * localProgress;
                    }
                } else {
                    // First part: travel along electrode to edge
                    if (signal.progress < 0.5) {
                        const localProgress = signal.progress / 0.5;
                        currentX = signal.startX;
                        currentY = signal.startY + (canvas.height - MARGIN - signal.startY) * localProgress;
                    } else {
                        // Second part: travel along wire to controller
                        const localProgress = (signal.progress - 0.5) / 0.5;
                        currentX = signal.startX + (signal.endX - signal.startX) * localProgress;
                        currentY = canvas.height - MARGIN + (signal.endY - (canvas.height - MARGIN)) * localProgress;
                    }
                }
                
                // Draw signal pulse
                ctx.beginPath();
                ctx.arc(currentX, currentY, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw glow effect
                ctx.beginPath();
                ctx.arc(currentX, currentY, 15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(34, 197, 94, 0.3)';
                ctx.fill();
                
                // Label
                if (signal.progress < 0.3) {
                    ctx.fillStyle = '#22c55e';
                    ctx.font = 'bold 12px Arial';
                    if (signal.type === 'horizontal') {
                        ctx.fillText('SIGNAL', currentX, currentY - 15);
                    } else {
                        ctx.fillText('SIGNAL', currentX + 15, currentY);
                    }
                }
            }
        }
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawFieldLines();
            drawElectrodes();
            drawWires();
            drawControllers();
            drawTouchPoints();
            drawSignals();
            
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>
